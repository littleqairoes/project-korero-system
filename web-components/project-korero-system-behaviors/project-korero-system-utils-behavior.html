<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/app-storage/app-network-status-behavior.html">
<link rel="import" href="../../web-components/project-korero-system-script/modernizr.html">

<script>
  (function() {

  /** @polymerBehavior KORERO.UtilsBehavior */
    KORERO.UtilsBehaviorImpl = {
      properties: {
        version: {
          type: String,
          readOnly: true,
          value: function() { return this._version; }
        }
      },

      get _version() {
        return 'v1'
      },

      get _todayUTC() {
        return firebase ? firebase.database.ServerValue.TIMESTAMP : Date.now();
      },

      _forceZero: function(obj, zeroValue) {
        if (zeroValue === null || zeroValue === undefined) zeroValue = false;
        return typeof obj === 'object' && this._isEmpty(obj) ? zeroValue : obj;
      },

      _isEmpty: function(obj) {
        for(var prop in obj) {
          if(obj.hasOwnProperty(prop))
            return false;
        }
        return JSON.stringify(obj) === JSON.stringify({});
      },

      _trimText: function(text, length) {
        var l = length ? length : 35;
        if (typeof text === 'string') {
          return text.length >= l ? text.substring(0, l).trim() + '...' : text;
        }
      },

      _capitalizeFirstLetter: function(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      },

      _renderDate: function(d) {
        var date = d;
        if (typeof d === 'object' && d.value) {
          date = d.value;
        }
        var nd = new Date(date);
        return nd.toLocaleDateString() + ' - ' + nd.toLocaleTimeString();
      },

      _returnArrayElement: function(array, index) {
        return array ? array[index] : null;
      },

      _returnArrayElementAttribute: function(array, index, key) {
        return array[index] ? array[index][key] : null;
      },

      _showMessage: function(message, err) {
        // if (this.$$('#toaster')) {
        //   this.$$('#toaster').show(message);
        // } else if (!err) {
        //   console.log(message);
        // }

        KORERO.Elements.Template.$.toast.showMessage(message);

        if (err) {
          if (console.error) {
            console.error(message);
          } else {
            console.log(message);
          }
        }
      },

      _catchError: function(err) {
        if (window.Raven) {
          if (err.detail) {
            Raven.captureMessage("Error event", err.detail);
          } else {
            Raven.captureException(err);
          }
        }

        var error = err.detail ? err.detail : err;
        this._showMessage('Error: ' +  error.message, true);
      },

      _textToUrl: function(text) {
        return encodeURI(text);
      },

      _thisUrl: function() {
        return window.location.href;
      },

      _windowSize: function() {
        var width = 0;
        var height = 0;
        if (window && document) {
          if ( typeof window.innerWidth === 'number' ) {
            // Non-IE
            width = window.innerWidth;
            height = window.innerHeight;
          } else if ( document.documentElement && (
            document.documentElement.clientWidth ||
            document.documentElement.clientHeight )) {
            // IE 6+ in 'standards compliant mode'
            width = document.documentElement.clientWidth;
            height = document.documentElement.clientHeight;
          } else if ( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
            // IE 4 compatible
            width = document.body.clientWidth;
            height = document.body.clientHeight;
          }
        }

        return {width: width, height: height};
      },

      _heightNodeChanged: function(e, node) {
        var height;
        if (e.indexOf('vh')) {
          if (Modernizr && Modernizr.cssvhunit) {
            height = e;
          } else {
            height = (parseFloat(e.replace(/vh/g, '')) * this._windowSize().height) + 'px';
          }
        } else if (e.indexOf('px')) {
          height = e;
        } else {
          height = e + 'px';
        }

        node.style.height = height;
      },

      _timeToString: function(time) {
        return parseInt(time / 60, 10) + ':' + (parseInt(time % 60, 10) < 10 ? '0' : '') + parseInt(time % 60, 10);
      },

      isKorero: function(ui) {
        return ui === 'korero';
      },

      getUTC: function() {
        var t = new Date();
        var y = t.getFullYear();
        var m = t.getMonth();
        var d = t.getDate();
        var h = t.getHours();
        var min = t.getMinutes();
        var s = t.getSeconds();
        var mil = t.getMilliseconds();
        return Date.UTC(y, m, d, h, min, s, mil);
      },

      showSelectionDiv: function() {
        var selectedText;
        var pos;
        var range;
        var node;
        var startPos = 0;
        var endPos = 0;
        var selected = this.root.getSelection();
        if (selected) {
          selectedText = selected.toString();
          node = selected.anchorNode;
          if (selected.rangeCount > 0) {
            range = selected.getRangeAt(0);
            pos = range.getBoundingClientRect();
          }
        }
        return  {
          text: selectedText,
          pos: pos,
          node: node,
          range: range,
          start: startPos,
          end: endPos,
          selected: selected
        };
      },
      showSelection: function(textComponent) {
        var selectedText;
        var startPos = 0;
        var endPos = 0;
        // IE version
        if (document.selection != undefined) {
          textComponent.focus();
          var sel = document.selection.createRange();
          selectedText = sel.text;
        }
        // Mozilla version
        if (textComponent.selectionStart != undefined) {
          startPos = textComponent.selectionStart;
          endPos = textComponent.selectionEnd;
          if (textComponent.value && textComponent.value.substring) {
            selectedText = textComponent.value.substring(startPos, endPos);
          }
        }
        return  {
          text: selectedText,
          start: startPos,
          end: endPos
        };
      },
      getCaretCoordinates: function(element, position) {
        // The properties that we copy into a mirrored div.
        // Note that some browsers, such as Firefox,
        // do not concatenate properties, i.e. padding-top, bottom etc. -> padding,
        // so we have to do every single property specifically.
        var properties = [
          'direction',  // RTL support
          'boxSizing',
          'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
          'height',
          'overflowX',
          'overflowY',  // copy the scrollbar for IE
          'borderTopWidth',
          'borderRightWidth',
          'borderBottomWidth',
          'borderLeftWidth',
          'borderStyle',
          'paddingTop',
          'paddingRight',
          'paddingBottom',
          'paddingLeft',
          // https://developer.mozilla.org/en-US/docs/Web/CSS/font
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'fontStretch',
          'fontSize',
          'fontSizeAdjust',
          'lineHeight',
          'fontFamily',
          'textAlign',
          'textTransform',
          'textIndent',
          'textDecoration',  // might not make a difference, but better be safe
          'letterSpacing',
          'wordSpacing',
          'tabSize',
          'MozTabSize'
        ];
        var isBrowser = (typeof window !== 'undefined');
        var isFirefox = (isBrowser && window.mozInnerScreenX != null);
        if(!isBrowser) {
          throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');
        }
        // mirrored div
        var div = document.createElement('div');
        div.id = 'input-textarea-caret-position-mirror-div';
        document.body.appendChild(div);
        var style = div.style;
        var computed = window.getComputedStyle? getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9
        // default textarea styles
        style.whiteSpace = 'pre-wrap';
        if (element.nodeName !== 'INPUT')
          style.wordWrap = 'break-word';  // only for textarea-s
        // position off-screen
        style.position = 'absolute';  // required to return coordinates properly
        style.visibility = 'hidden';  // not 'display: none' because we want rendering
        // transfer the element's properties to the div
        properties.forEach(function (prop) {
          style[prop] = computed[prop];
        });
        if (isFirefox) {
          // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
          if (element.scrollHeight > parseInt(computed.height, 10)) style.overflowY = 'scroll';
        } else {
          style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
        }
        div.textContent = element.value.substring(0, position);
        // the second special handling for input type="text" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
        if (element.nodeName === 'INPUT')
          div.textContent = div.textContent.replace(/\s/g, '\u00a0');
        var span = document.createElement('span');
        // Wrapping must be replicated *exactly*, including when a long word gets
        // onto the next line, with whitespace at the end of the line before (#7).
        // The  *only* reliable way to do that is to copy the *entire* rest of the
        // textarea's content into the <span> created at the caret position.
        // for inputs, just '.' would be enough, but why bother?
        span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all
        div.appendChild(span);
        var coordinates = {
          top: span.offsetTop + parseInt(computed['borderTopWidth'], 10),
          left: span.offsetLeft + parseInt(computed['borderLeftWidth'], 10)
        };
        document.body.removeChild(div);
        return coordinates;
      }
    }

    KORERO.UtilsBehavior = [
      Polymer.AppNetworkStatusBehavior,
      KORERO.UtilsBehaviorImpl
    ]
  })();
</script>
